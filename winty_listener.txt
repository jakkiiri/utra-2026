"use client"

import { useEffect, useRef, useCallback, useState } from "react"
import { Mic } from "lucide-react"

interface WakeWordListenerProps {
  onWakeWordDetected: () => void
  onTranscriptReady?: (transcript: string) => void
  enabled?: boolean
  isProcessing?: boolean
}

// Wake word patterns - various ways to say "Hey Winty"
const WAKE_WORD_PATTERNS = [
  /hey\s*wint(y|ie|ee)/i,
  /hello\s*wint(y|ie|ee)/i,
  /hi\s*wint(y|ie|ee)/i,
  /okay\s*wint(y|ie|ee)/i,
  /ok\s*wint(y|ie|ee)/i,
  /yo\s*wint(y|ie|ee)/i,
  /wint(y|ie|ee)/i,  // Just "Winty" alone
]

export function WakeWordListener({
  onWakeWordDetected,
  onTranscriptReady,
  enabled = true,
  isProcessing = false
}: WakeWordListenerProps) {
  const [isListening, setIsListening] = useState(false)
  const [wakeWordActive, setWakeWordActive] = useState(false)
  const recognitionRef = useRef<SpeechRecognition | null>(null)
  const restartTimeoutRef = useRef<NodeJS.Timeout | null>(null)

  // Check if transcript contains wake word
  const containsWakeWord = useCallback((text: string): boolean => {
    const normalizedText = text.toLowerCase().trim()
    return WAKE_WORD_PATTERNS.some(pattern => pattern.test(normalizedText))
  }, [])

  // Extract the question after the wake word
  const extractQuestionAfterWakeWord = useCallback((text: string): string => {
    const normalizedText = text.toLowerCase()
    
    // Try to find and remove wake word patterns
    for (const pattern of WAKE_WORD_PATTERNS) {
      const match = normalizedText.match(pattern)
      if (match) {
        const index = normalizedText.indexOf(match[0])
        const afterWakeWord = text.slice(index + match[0].length).trim()
        // Remove common filler words at the start
        return afterWakeWord.replace(/^(um|uh|so|like|well|,|\s)+/i, '').trim()
      }
    }
    return text
  }, [])

  // Start continuous listening for wake word
  const startListening = useCallback(() => {
    if (!recognitionRef.current || isProcessing) return

    try {
      recognitionRef.current.start()
      setIsListening(true)
    } catch (error) {
      // Already started, ignore
    }
  }, [isProcessing])

  // Initialize speech recognition
  useEffect(() => {
    if (typeof window === 'undefined') return
    if (!('SpeechRecognition' in window || 'webkitSpeechRecognition' in window)) return

    const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition
    recognitionRef.current = new SpeechRecognitionAPI()
    recognitionRef.current.continuous = true  // Keep listening
    recognitionRef.current.interimResults = true
    recognitionRef.current.lang = 'en-US'

    recognitionRef.current.onresult = (event) => {
      let transcript = ""
      
      for (let i = event.resultIndex; i < event.results.length; i++) {
        transcript += event.results[i][0].transcript
      }

      // Check for wake word in the transcript
      if (containsWakeWord(transcript)) {
        console.log('ðŸŽ¤ Wake word detected:', transcript)
        setWakeWordActive(true)
        
        // Stop this recognition session
        recognitionRef.current?.stop()
        
        // Notify parent
        onWakeWordDetected()
        
        // Extract and send any question that came after the wake word
        const question = extractQuestionAfterWakeWord(transcript)
        if (question && question.length > 2 && onTranscriptReady) {
          // Wait a moment then send the question
          setTimeout(() => {
            onTranscriptReady(question)
          }, 500)
        }
        
        // Reset wake word state after a delay
        setTimeout(() => {
          setWakeWordActive(false)
        }, 3000)
      }
    }

    recognitionRef.current.onend = () => {
      setIsListening(false)
      
      // Auto-restart after a short delay if enabled and not processing
      if (enabled && !isProcessing && !wakeWordActive) {
        restartTimeoutRef.current = setTimeout(() => {
          startListening()
        }, 500)
      }
    }

    recognitionRef.current.onerror = (event) => {
      if (event.error !== 'aborted' && event.error !== 'no-speech') {
        console.warn('Wake word listener error:', event.error)
      }
      setIsListening(false)
    }

    // Start listening if enabled
    if (enabled && !isProcessing) {
      startListening()
    }

    return () => {
      if (restartTimeoutRef.current) {
        clearTimeout(restartTimeoutRef.current)
      }
      if (recognitionRef.current) {
        recognitionRef.current.abort()
      }
    }
  }, [enabled, isProcessing, containsWakeWord, extractQuestionAfterWakeWord, onWakeWordDetected, onTranscriptReady, startListening, wakeWordActive])

  // Handle enabled state changes
  useEffect(() => {
    if (enabled && !isProcessing && !isListening) {
      startListening()
    } else if (!enabled && recognitionRef.current) {
      recognitionRef.current.abort()
    }
  }, [enabled, isProcessing, isListening, startListening])

  // Don't render anything visible - this is a background listener
  // But show a small indicator when actively listening
  if (!enabled) return null

  return (
    <div className="fixed bottom-4 right-4 z-40">
      <div 
        className={`flex items-center gap-2 px-3 py-1.5 rounded-full text-xs transition-all ${
          wakeWordActive 
            ? 'bg-green-500/20 text-green-400 border border-green-500/30' 
            : isListening 
              ? 'bg-white/5 text-white/40 border border-white/10' 
              : 'bg-white/5 text-white/20 border border-white/5'
        }`}
        title={isListening ? "Say 'Hey Winty' to ask a question" : "Wake word listener paused"}
      >
        <Mic className={`size-3 ${wakeWordActive ? 'animate-pulse' : ''}`} />
        <span className="hidden sm:inline">
          {wakeWordActive ? 'Listening...' : isListening ? 'Say "Hey Winty"' : 'Paused'}
        </span>
      </div>
    </div>
  )
}

// Extend Window interface for Speech Recognition
declare global {
  interface Window {
    SpeechRecognition: typeof SpeechRecognition
    webkitSpeechRecognition: typeof SpeechRecognition
  }
}
